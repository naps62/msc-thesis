\documentclass[main.tex]{subfiles}

\begin{document}

\section{Testing Methodology} \label{sec:results:method}

Measurements were done only in the algorithmic section of the program, disregarding any input/ouput operations as well as initial setup of \starpu and other libraries. In the main rendering loop, the time for each full iteration of the SPPMPA algorithm was measured (see \cref{fig:diagram_cpu}, which explains how iterations are organized). This was done by obtaining the timestamp at the beginning of each iteration, and at the end of the last task of the same iteration, which also works well when using concurrent iterations. The full iteration time includes the required data transfer times, but more granular values were obtained, by measuring the time for each invoked task of each iteration, which does not account for data transfers. Presented results show only the average time of each iteration for the execution (with at least 100 iterations each).
Since evaluating the framework includes analyse how data transfers affect performance in the different approaches, average iteration time, which includes these values, was the chosen unit for comparisons. Task execution time was used for an estimation of workload distribution.

Since the entire main loop consists solely on task invocations, it was assumed that the difference between total iteration time and the sum of each task within the iteration corresponds to idle periods when the framework is waiting for resources or dependencies, or performing data transfers.

For each measurement, only the time spent in the main rendering function was considered, discarding any input and output time spent by the program. A minimum of 10 executions were made for each measurement, for which the 3 best executions within at most $5\%$ of each other were considered. When comparing results, the average time for each iteration of the main loop of SPPMPA was the base value to use (with each test running at least 20 iterations).

Whenever \cuda was employed, the \cuda Occupancy Calculator\footnote{A spreadsheet by \nvidia that helps estimating the ideal block size for a given kernel}, as well as manual tuning, were used to find the correct block size used for each computational kernel.

\subsection{Input Scene}

For simplicity, input reading was left to the LuxRender library, relying on the existing structures and parser to read all the data to render a scene. This limits all testing to the available scenes shipped with LuxRender as samples. From these scenes, only three scenes were selected, namely, \textbf{kitchen}, \textbf{cornell} and \textbf{luxball}.

\end{document}
