\documentclass[main.tex]{subfiles}

\begin{document}

\chapter{Conclusions} \label{chapter:conclusions}
\itodo{this}

\section{StarPU}
\itodo{type safety}
\itodo{memory management not as powerful as gama's}
\itodo{granularity must be programmer-defined. gama has dicing}

\subsection{Performance}
\itodo{this}

\itodo{memory management concerns: A framework such as \starpu can be smart enough to use the information such as the task dependency graph and history based execution to asynchronously prepare all memory where it knows it will be needed further in the execution}
\itodo{accessing data that was assigned to a handle, when outside of a task, can lead to incoherent memory}
\itodo{data access modes do not ensure correctness. a task may write to a STARPU\_R buffer. it just happens that, if a data transfer of that buffer is required for a different task, those writes might not be considered, although they will remain in the original node. This leads to memory incosistencies, caused by a mistake by the programmer (STARPU\_R should have been STARPU\_RW). the framework should not allow that mistake to happen}
\itodo{memoria de tamanho variavel ou estrutura irregular. While it is unsure whether \starpu actually allows such a thing...}

\subsection{Usability}

\itodo{talk about usability from the developer point of view, and scientist point of view. is it easy to use?}

\itodo{improve the implementation (i.e. remove seeds and partition data?)}
\itodo{test pragma based api}
\itodo{compare to GAMA}

\itodo{starpu impossible to have device-specific structures that are not translatable between each other. If a \gpu works better with a structure X, and a \cpu with a structure Y, and it is impossible to directly translating X to Y, then \starpu cant be allowed to generate X on a \gpu, only to later process it on a cpu in a subsequent task}


\end{document}
